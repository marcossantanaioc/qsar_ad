# AUTOGENERATED! DO NOT EDIT! File to edit: AD.ipynb (unless otherwise specified).

__all__ = ['BaseDomain', 'kNNDomain', 'SVMDomain']

# Cell
import pandas as pd
import numpy as np
import scipy.stats as stats
import statsmodels.api as st
from scipy.spatial import distance

# Cell
class BaseDomain:
     def calculate_applicability_domain(self):
        pass

# Cell
class kNNDomain(BaseDomain):

    def __init__(self, Xref:np.array, metric='euclidean'):

        """Calculates the applicability domain using the k-nearest neighbours approach

        Attributes
        -----------------------------------------------------------------------------

        Xref : numpy.array
            Reference fingerprints

        metric : str or callable, optional
            The distance metric to use.
            If a string, the distance function can be ‘braycurtis’, ‘canberra’, ‘chebyshev’,
            ‘cityblock’, ‘correlation’, ‘cosine’, ‘dice’, ‘euclidean’, ‘hamming’, ‘jaccard’,
            ‘jensenshannon’, ‘kulsinski’, ‘kulczynski1’, ‘mahalanobis’, ‘matching’, ‘minkowski’,
            ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’.



        """


        self.Xref = Xref
        self.metric = metric
        self.ad_threshold = self.calculate_ad_threhold(metric=metric)


    @property
    def ad_threshold(self):
        return self._ad_threshold

    @ad_threshold.setter
    def ad_threshold(self, v):
        self._ad_threshold = v

    def calculate_similarity_from_array(self, fp1:np.array, fp2:np.array=None, metric:str=None, z=0.5):

        """Calculates a squared similarity matrix between two arrays of fingerprints

        Arguments
        -----------------------------------------------------------------------------

        fp1 : numpy.array
            An array of fingerprints.

        fp2 : numpy.array
            Second array of fingerprints. If None, defaults to `fp1`.

        metric : str or callable, optional
            The distance metric to use.
            If a string, the distance function can be ‘braycurtis’, ‘canberra’, ‘chebyshev’,
            ‘cityblock’, ‘correlation’, ‘cosine’, ‘dice’, ‘euclidean’, ‘hamming’, ‘jaccard’,
            ‘jensenshannon’, ‘kulsinski’, ‘kulczynski1’, ‘mahalanobis’, ‘matching’, ‘minkowski’,
            ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’.


        z : float
            Significance threshold. See original publication for more details: https://pubs.acs.org/doi/10.1021/ci060132x


        Returns
        -----------------------------------------------------------------------------

        simi_matrix : numpy.array
            A matrix with pairwise distance.


        """

        from scipy.spatial import distance
        if fp2 is None:
            simi_matrix = distance.cdist(fp1, fp1, metric=metric).squeeze()
        else:
            simi_matrix = distance.cdist(fp1, fp2, metric=metric).squeeze()
        return simi_matrix

    def calculate_ad_threhold(self, X:np.array=None,  metric:str=None, z=0.5):

        """Calculates the applicability domain threhold using k-NN method

        Arguments
        -----------------------------------------------------------------------------

        X : numpy.array
            An array of fingerprints.

        metric : str or callable, optional
            The distance metric to use.
            If a string, the distance function can be ‘braycurtis’, ‘canberra’, ‘chebyshev’,
            ‘cityblock’, ‘correlation’, ‘cosine’, ‘dice’, ‘euclidean’, ‘hamming’, ‘jaccard’,
            ‘jensenshannon’, ‘kulsinski’, ‘kulczynski1’, ‘mahalanobis’, ‘matching’, ‘minkowski’,
            ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’.

        z : float
            Significance threshold. See original publication for more details: https://pubs.acs.org/doi/10.1021/ci060132x


        Returns
        -----------------------------------------------------------------------------

        ad_threshold : float
            The distance threshold used to define the applicability domain.


        """

        from scipy.spatial import distance

        X = self.Xref if X is None else X
        simi_matrix = self.calculate_similarity_from_array(X, metric=metric).squeeze()

        std_distances = np.std(simi_matrix) # std of distances
        avg_distances = np.mean(simi_matrix) # average of distances

        # Applicability threhold
        ad_threshold = (z*std_distances) + avg_distances
        return ad_threshold

    def get_knn(self, fp:np.array, ref_fp:np.array=None, k:int=10):

        """Get the k-nearest neighbours and calculate the distance between fp and ref_fps.

        Arguments
        -----------------------------------------------------------------------------
        fp : numpy.array
            Query fingerprint

        ref_fps : numpy.array
            Reference fingerprints

        k : int
            Number of k nearest neighbours


        Returns
        -----------------------------------------------------------------------------
        distances : numpy.array
            A matrix with pairwise distance.

        neighbours : numpy.array
            Index of k-nearest neighbours


        """

        # Generate similarity matrix
        ref_fp = self.Xref if ref_fp is None else ref_fp
        distances = self.calculate_similarity_from_array(fp, ref_fp, metric=self.metric).reshape(len(fp), len(ref_fp))
        # Get kNN
        neighbours = np.argsort(distances, axis=-1).reshape(len(fp), len(ref_fp))
        return distances, neighbours
#         # Generate similarity matrix
#         ref_fp = self.Xref if ref_fp is None else ref_fp
#         distances = self.calculate_similarity_from_array(fp, ref_fp)
#         # Get kNN
#         neighbours = np.argsort(distances)[: k]
#         return distances, neighbours

    def calculate_applicability_domain(self, fp:np.array, ref_fp:np.array=None, k:int=10):


        """Get the k-nearest neighbours and calculate the distance between fp and ref_fps.

        Arguments
        -----------------------------------------------------------------------------

        fp : numpy.array
            Query fingerprint

        ref_fps : numpy.array
            Reference fingerprints

        k : int
            Number of k nearest neighbours

        Returns
        -----------------------------------------------------------------------------

        avg_distance : float
            Average distance between query and k-nearest neighbours in AD.


        """
        assert k >=1, "k must be >= 1."
        ref_fp = self.Xref if ref_fp is None else ref_fp
        distances, neighbours = self.get_knn(fp, ref_fp, k=k)
        avg_distance = np.take_along_axis(distances, neighbours[:, :k], 1).mean(-1)
        return (avg_distance,avg_distance<=self.ad_threshold)

        #avg_distance = distances[neighbours].mean()
        #return (avg_distance, True) if avg_distance <= self.ad_threshold else (avg_distance, False)

# Cell
class SVMDomain:
    from sklearn.svm import OneClassSVM
    def __init__(self, Xref:np.array, svm_model=None):

        """Calculates the applicability domain using the k-nearest neighbours approach

        Attributes
        -----------------------------------------------------------------------------

        Xref : numpy.array
            Reference fingerprints


        """

        self.Xref = Xref
        self.svm_model = OneClassSVM() if svm_model is None else svm_model


    @property
    def svm_model(self):
        return self._svm_model

    @svm_model.setter
    def svm_model(self, v):
        self._svm_model = v

    def train_model(self, X:np.array=None, params={}):

        """Train a One class SVM model for outlier detection.

        Arguments
        -----------------------------------------------------------------------------

        X : numpy.array
            An array of fingerprints for the training set


        params : dict
           A dictionary of parameters for OneClassSVM

        Returns
        -----------------------------------------------------------------------------

        svm_model : Fitted estimator


        """


        X = self.Xref if X is None else X
        self.svm_model.set_params(**params)
        self.svm_model.fit(X)
        return self.svm_model

    def calculate_applicability_domain(self, Xtest:np.array=None):

        """Perform classification on samples in Xtest.

        Arguments
        -----------------------------------------------------------------------------

        Xtest : numpy.array
            An array of fingerprints.

        Returns
        -----------------------------------------------------------------------------

        class_label : int
            For a one-class model, +1 or -1 is returned.


        """

        return self.svm_model.predict(Xtest)